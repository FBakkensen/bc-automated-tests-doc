"""Tests for minimal Markdown rendering functionality."""

from __future__ import annotations

import tempfile
from pathlib import Path

import pytest

from pdf2md.config import ToolConfig
from pdf2md.models import SectionNode
from pdf2md.render import generate_filename, render_section_stub, render_sections


@pytest.fixture
def config() -> ToolConfig:
    """Create test configuration with default settings."""
    return ToolConfig()


@pytest.fixture
def custom_config() -> ToolConfig:
    """Create test configuration with custom settings."""
    return ToolConfig(slug_prefix_width=3, default_slug_fallback="no-title")


@pytest.fixture
def simple_section() -> SectionNode:
    """Create a simple section without prefix in slug."""
    return SectionNode(title="Intro", level=1, slug="intro")


@pytest.fixture
def prefixed_section() -> SectionNode:
    """Create a section with prefixed slug (as generated by build_tree)."""
    return SectionNode(title="Data Analysis", level=1, slug="01-data-analysis")


@pytest.fixture
def section_without_slug() -> SectionNode:
    """Create a section without a slug."""
    return SectionNode(title="No Slug Section", level=1, slug=None)


@pytest.fixture
def nested_sections() -> list[SectionNode]:
    """Create nested sections for hierarchy testing."""
    parent = SectionNode(title="Parent Chapter", level=1, slug="parent-chapter")
    child = SectionNode(title="Child Section", level=2, slug="child-section")
    parent.add_child(child)
    return [parent]


class TestGenerateFilename:
    """Tests for filename generation following slug policy."""

    def test_prefixed_slug_used_directly(
        self, prefixed_section: SectionNode, config: ToolConfig
    ) -> None:
        """Test that sections with prefixed slugs use them directly without double-prefixing."""
        filename = generate_filename(prefixed_section, 5, config)
        assert filename == "01-data-analysis.md"

    def test_simple_slug_gets_prefix(self, simple_section: SectionNode, config: ToolConfig) -> None:
        """Test that simple slugs get prefix added."""
        filename = generate_filename(simple_section, 1, config)
        assert filename == "01-intro.md"

    def test_missing_slug_uses_fallback(
        self, section_without_slug: SectionNode, config: ToolConfig
    ) -> None:
        """Test filename generation when section has no slug."""
        filename = generate_filename(section_without_slug, 1, config)
        assert filename == "01-untitled.md"

    def test_custom_fallback_used(
        self, section_without_slug: SectionNode, custom_config: ToolConfig
    ) -> None:
        """Test that custom fallback slug is used when configured."""
        filename = generate_filename(section_without_slug, 1, custom_config)
        assert filename == "001-no-title.md"

    def test_custom_width_respected(
        self, simple_section: SectionNode, custom_config: ToolConfig
    ) -> None:
        """Test that custom slug_prefix_width is respected."""
        filename = generate_filename(simple_section, 5, custom_config)
        assert filename == "005-intro.md"

    def test_large_prefix_index(self, simple_section: SectionNode, config: ToolConfig) -> None:
        """Test filename generation with large prefix index."""
        filename = generate_filename(simple_section, 123, config)
        assert filename == "123-intro.md"


class TestRenderSectionStub:
    """Tests for section content rendering."""

    def test_renders_h1_heading_only(self) -> None:
        """Test that section is rendered as H1 heading only."""
        section = SectionNode(title="Intro", level=1)
        content = render_section_stub(section)
        assert content == "# Intro\n"

    def test_renders_different_titles(self) -> None:
        """Test rendering sections with different titles."""
        # Simple title
        section1 = SectionNode(title="Overview", level=2)
        content1 = render_section_stub(section1)
        assert content1 == "# Overview\n"

        # Complex title with numbers and punctuation
        section2 = SectionNode(title="Chapter 1: Data Analysis", level=1)
        content2 = render_section_stub(section2)
        assert content2 == "# Chapter 1: Data Analysis\n"

    def test_renders_title_with_special_characters(self) -> None:
        """Test rendering titles with special characters."""
        section = SectionNode(title="Analysis & Results", level=1)
        content = render_section_stub(section)
        assert content == "# Analysis & Results\n"


class TestRenderSections:
    """Tests for rendering multiple sections to files."""

    def test_creates_book_directory(self, config: ToolConfig, simple_section: SectionNode) -> None:
        """Test that render_sections creates book subdirectory."""
        with tempfile.TemporaryDirectory() as tmpdir:
            output_dir = Path(tmpdir)
            written_files = render_sections([simple_section], output_dir, config)

            book_dir = output_dir / "book"
            assert book_dir.exists()
            assert book_dir.is_dir()
            assert len(written_files) == 1

    def test_custom_book_subdir_name(self, config: ToolConfig, simple_section: SectionNode) -> None:
        """Test rendering with custom book subdirectory name."""
        with tempfile.TemporaryDirectory() as tmpdir:
            output_dir = Path(tmpdir)
            written_files = render_sections(
                [simple_section], output_dir, config, book_subdir="chapters"
            )

            chapters_dir = output_dir / "chapters"
            assert chapters_dir.exists()
            assert len(written_files) == 1
            # Verify files are in the custom directory
            for file_path in written_files:
                assert file_path.parent.name == "chapters"

    def test_filename_and_content_generation(
        self, config: ToolConfig, nested_sections: list[SectionNode]
    ) -> None:
        """Test that files are created with correct names and contents."""
        with tempfile.TemporaryDirectory() as tmpdir:
            output_dir = Path(tmpdir)
            written_files = render_sections(nested_sections, output_dir, config)

            assert len(written_files) == 2  # 1 parent + 1 child section

            # Check filenames follow expected pattern (pre-order traversal)
            expected_filenames = [
                "01-parent-chapter.md",  # Parent section
                "02-child-section.md",  # Child section
            ]

            actual_filenames = [f.name for f in written_files]
            assert actual_filenames == expected_filenames

            # Check file contents
            for file_path in written_files:
                content = file_path.read_text(encoding="utf-8")

                if file_path.name == "01-parent-chapter.md":
                    assert content == "# Parent Chapter\n"
                elif file_path.name == "02-child-section.md":
                    assert content == "# Child Section\n"

    def test_preorder_traversal_ordering(self, config: ToolConfig) -> None:
        """Test that sections are processed in pre-order (parent before children)."""
        # Create deeper hierarchy to test traversal order
        root = SectionNode(title="Root", level=1, slug="root")
        child1 = SectionNode(title="Child 1", level=2, slug="child-1")
        child2 = SectionNode(title="Child 2", level=2, slug="child-2")
        grandchild = SectionNode(title="Grandchild", level=3, slug="grandchild")

        # Build hierarchy: root -> child1 -> grandchild, root -> child2
        root.add_child(child1)
        root.add_child(child2)
        child1.add_child(grandchild)

        with tempfile.TemporaryDirectory() as tmpdir:
            output_dir = Path(tmpdir)
            written_files = render_sections([root], output_dir, config)

            # Should be: root, child1, grandchild, child2 (pre-order)
            expected_filenames = [
                "01-root.md",
                "02-child-1.md",
                "03-grandchild.md",
                "04-child-2.md",
            ]

            actual_filenames = [f.name for f in written_files]
            assert actual_filenames == expected_filenames

    def test_relative_paths_are_correct(
        self, config: ToolConfig, simple_section: SectionNode
    ) -> None:
        """Test that returned file paths are relative to output directory."""
        with tempfile.TemporaryDirectory() as tmpdir:
            output_dir = Path(tmpdir)
            written_files = render_sections([simple_section], output_dir, config)

            # All files should be under book/ subdirectory
            for file_path in written_files:
                rel_path = file_path.relative_to(output_dir)
                assert rel_path.parts[0] == "book"
                assert len(rel_path.parts) == 2  # book/{filename}.md
                assert rel_path.suffix == ".md"

    def test_empty_sections_list(self, config: ToolConfig) -> None:
        """Test rendering with empty sections list."""
        with tempfile.TemporaryDirectory() as tmpdir:
            output_dir = Path(tmpdir)
            written_files = render_sections([], output_dir, config)

            # Should create book directory but no files
            book_dir = output_dir / "book"
            assert book_dir.exists()
            assert len(written_files) == 0

    def test_file_writing_utf8_encoding(self, config: ToolConfig) -> None:
        """Test that files are written with UTF-8 encoding."""
        section = SectionNode(title="Résumé & Café", level=1, slug="resume-cafe")

        with tempfile.TemporaryDirectory() as tmpdir:
            output_dir = Path(tmpdir)
            written_files = render_sections([section], output_dir, config)

            assert len(written_files) == 1
            content = written_files[0].read_text(encoding="utf-8")
            assert content == "# Résumé & Café\n"


class TestIntegrationScenario:
    """Integration tests matching the issue requirements."""

    def test_issue_scenario_exact_match(self, config: ToolConfig) -> None:
        """Test exact scenario from issue: section with title 'Intro' generates correct file."""
        # Given a section with title "Intro"
        section = SectionNode(title="Intro", level=1, slug="intro")

        with tempfile.TemporaryDirectory() as tmpdir:
            output_dir = Path(tmpdir)

            # When rendering Markdown
            written_files = render_sections([section], output_dir, config)

            # Then file `book/01-intro.md` exists with heading line
            expected_file = output_dir / "book" / "01-intro.md"
            assert expected_file.exists()
            assert expected_file in written_files

            content = expected_file.read_text(encoding="utf-8")
            assert content == "# Intro\n"

    def test_multiple_sections_for_comprehensive_validation(self, config: ToolConfig) -> None:
        """Test with 2-3 sections as required by definition of done."""
        # Create 3 sections to test comprehensive behavior
        sections = [
            SectionNode(title="Introduction", level=1, slug="introduction"),
            SectionNode(title="Methodology", level=1, slug="methodology"),
            SectionNode(title="Results", level=1, slug="results"),
        ]

        with tempfile.TemporaryDirectory() as tmpdir:
            output_dir = Path(tmpdir)
            written_files = render_sections(sections, output_dir, config)

            # Verify all files exist with correct names
            expected_files = [
                output_dir / "book" / "01-introduction.md",
                output_dir / "book" / "02-methodology.md",
                output_dir / "book" / "03-results.md",
            ]

            for expected_file in expected_files:
                assert expected_file.exists()
                assert expected_file in written_files

            # Verify contents
            assert expected_files[0].read_text() == "# Introduction\n"
            assert expected_files[1].read_text() == "# Methodology\n"
            assert expected_files[2].read_text() == "# Results\n"
